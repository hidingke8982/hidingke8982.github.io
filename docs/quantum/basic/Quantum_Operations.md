---
parent: Basic
nav_order: 4
title: Quantum Operations
---

# Quantum Operations



## 양자 게이트(Quantum Gate)
양자 게이트는 양자 컴퓨터의 연산 단위로, 큐비트의 상태를 조작하는 기본 연산자. 선형대수적으로 회전시키거나 얽히게 만드는 유니터리 행렬이다.  
큐비트의 상태벡터에 행렬을 곱하는 방식으로 조작.

### 1-큐비트 게이트(Single-Qubit Gate)
단일 큐비트의 상태 벡터 방향을 회전시키거나 중첩을 만들어내는 게이트.
- Pauli-X 게이트: x축을 기준으로 대칭시키면, z축 좌표의 부호가 반전되어 0과 1의 확률이 서로 바뀌게 됩니다.
- Hadamard 게이트: 중첩인 상태를 만들어주는 게이트. 예를 들어서 100% 확률로 0인 큐비트를 넣으면, 50% 확률로 0이고 50% 확률로 1인 반반 확률 큐비트가 나오게 됩니다.

### 2-큐비트 게이트(Two-Qubit Gate)
두 큐비트를 얽히게 하거나, 한 큐비트의 상태에 따라 다른 큐비트 연산 수행하는 게이트.
- CNOT(Controlled NOT) 게이트: 두 개의 큐비트를 대상으로 동작하는데, 하나는 컨트롤 큐비트, 하나는 타겟 큐비트라고 부른다. 컨트롤 큐비트가 0이면 타겟 큐비트는 그대로, 1이면 0<->1로 뒤집히는 구조. 
- CX(Controlled Pauli-X) 게이트: 두 개의 큐비트를 대상으로 동작하는데, 하나는 컨트롤 큐비트, 하나는 타겟 큐비트라고 부른다. 컨트롤 큐비트가 1일 때만 타겟 큐비트에 Pauli-X 게이트의 역할을 하는 게이트.



## 양자 회로(Quantum Circuit)
양자 회로는 시간의 흐름에 따라 큐비트에 어떤 양자 게이트(연산)를 적용할지 지정하는 설계도이자 명령 시퀀스다.
- 구성 요소
    - Wires: 시간의 흐름을 나타내며, 각 선은 하나의 큐비트를 나타낸다.
    - Gates: 큐비트의 상태를 변화시키는 연산(행렬)이다.
    - Measurement: 양자 상태를 붕괴시켜 고전적인 비트 값으로 변환한다.



## 양자 알고리즘(Quantum Algorithm)
양자 알고리즘(Quantum Algorithm)은 양자 컴퓨터가 고전 컴퓨터보다 더 빠르게 혹은 더 효율적으로 문제를 해결할 수 있도록 설계된 논리적인 계산 절차이다. 양자 알고리즘의 혁신은 단순히 계산 속도를 높이는 것이 아니라, 양자 역학의 원리를 이용하여 문제를 해결하는 방식 자체를 근본적으로 바꾸는 데 있다.
- 양자 알고리즘 구조
    - 초기화 및 중첩: 모든 가능한 입력 상태를 동시에 탐색하기 위한 환경 조성
    - 오라클/연산 적용: 문제의 정답을 식별하고, 정답 경로에만 위상(Phase) 변화를 부여
    - 진폭 증폭: 간섭을 통해 정답 확률을 높이고 오답 확률을 낮추는 반복 과정
    - 최종 측정: 재편성된 상태를 관측하여 가장 높은 확률의 결과를 출력
- 대표적인 양자 알고리즘
    - 쇼어 알고리즘(Shor's Algorithm): 큰 숫자의 소인수 분해
    - 그로버 알고리즘(Grover's Algorithm): 구조화되지 않은 데이터베이스 탐색
    - VQE(Variational Quantum Eigensolver): 분자/재료의 바닥 상태 에너지 계산

알고리즘이란, 특정한 문제를 해결하기 위한 절차를 말합니다. 컴퓨터는 주어진 문제를 해결하기 위해서, 정해진 절차를 따라가며 계산을 합니다. 여기서 문제는 어떤 것이든 될 수 있습니다.  
아주 간단한 문제를 하나 볼까요? 0부터 7까지의 정수 중에서 무작위하게 하나를 고르고, 컴퓨터에게 고른 숫자가 무엇인지 맞춰보라는 문제를 내봅시다.
- Case 고전 컴퓨터:  
아무런 정보가 없는 상태에서 랜덤한 숫자를 맞추라고 하니 그냥 하나씩 넣어보는 방법 밖에는 없는 것입니다. 각 시도에서 정답을 맞출 확률은 1/8 이겠죠.  
그나마 아까 보여드린 예시에서는 세번째 시도만에 맞추었지만, 운이 정말 안좋다면 7번만에 맞추었을 수도 있습니다. 숫자의 범위가 커지면 커질수록 각 시도에서 정답을 맞출 확률은 줄어듭니다. 만약 숫자의 범위가 1 부터 1,000,000이었다면? 로또를 사는 것이 차라리 나아보입니다.
- Case 양자 컴퓨터:  
가령, "큐비트는 모든 상태가 중첩되어 있기 때문에 가능한 상태를 모두 병렬적으로 동시에 확인해볼 수 있다" 라고 생각하시는 경우가 있습니다. 이 말이 맞다면, 양자 컴퓨터는 숫자 맞추기 문제를 항상 첫번째 시도만에 해결할 수 있을 것입니다. 0부터 7까지 중첩된 상태를 넣으면 그 중 하나는 정답일테니까요. 하지만 불행하게도 이는 사실이 아닙니다.  
입력을 정답과 비교하기 위해서 "관측"을 합니다. 바로 이 관측 단계에서 문제가 발생합니다. 양자 중첩 상태는 관측을 하는 순간 하나의 상태로 결정되며, 중첩인 상태가 풀린다고 했었죠. 중첩 상태인 큐비트를 넣어봤자 정답과 비교하기 위해 관측을 하는 이상 하나로 결정된 상태를 넣은 것이나 다름 없습니다.  
틀린 답안을 관측하게 될 확률이 더 높고, 맞는 답안을 관측하게 될 확률은 현저하게 작습니다. 즉, 중첩이 되었건 어쨌건 마지막에 관측을 했을 때 정답이 나오게 될 확률은 여전히 1/8인 것입니다. 나머지 7/8 확률로는 오답을 관측하게 됩니다. 그럼, 결국에는 고전 컴퓨터랑 똑같을 뿐인데 대체 양자 컴퓨터가 왜 효율적이라는 것이며, 어떤게 혁신적이라는 것일까요?  
양자 컴퓨터의 혁신성은 양자 알고리즘에 있습니다. 양자 알고리즘은, 양자역학의 원리를 이용해서 틀린 답안이 관측될 확률을 줄이고 맞는 답안이 관측될 확률을 높입니다. 실제로 관측을 하기 전에 말이죠. 그렇게 되면, 관측을 했을 때 더 높은 확률로 맞는 답안이 나오게 될 것이고, 궁극적으로는 전체적인 알고리즘 실행 시간이 줄어들게 되는 것입니다. 정답을 맞추기 위해 무작위하게 때려 맞추는 횟수가 훨씬 더 줄어들기 때문입니다.  
(자세한 과정은 너무 어려움...) 간단히 말해 두 개의 확률을 파동처럼 서로 간섭시키거나 증폭시켜, 오답일 확률을 줄이거나 정답일 확률을 높여서 계산의 효율을 높일 수 있다.  
하지만, 모든 알고리즘을 양자 컴퓨터가 고전 컴퓨터보다 더 빠르게 실행할 수 있는 것은 아닙니다. 확률 파동의 간섭 현상을 적절하고 효율적으로 활용할 수 있는 양자 알고리즘이 새로 개발되어야하기 때문입니다. 그리고 이는 굉장히 어려운 일입니다.
양자 컴퓨터가 고전 컴퓨터보다 더 빠르게 해결할 수 있는 문제가 많아지면 많아질수록 양자 컴퓨터의 범용성은 올라갈 것이고, 과학 연구 분야에 유용하게 사용될 수 있을 것입니다.

컴퓨터의 용도는 '정답(값)을 출력'하는 것이고, 양자컴퓨터 또한 이에 벗어나지 않는다는 것을 먼저 생각해야 한다. 양자컴퓨터는 고전 컴퓨터와 다른 점이 있다. 고전 컴퓨터는 '확정적인 정답'을 출력하는 기계다. 1+1은 무조건 2라는 식의 확정적인 정답만을 출력한다. 하지만 양자컴퓨터는 다르다. 정답을 정답으로써 출력하는 게 아니다. '정답일 확률이 가장 높은 값'을 정답으로 출력하는 것이다.
